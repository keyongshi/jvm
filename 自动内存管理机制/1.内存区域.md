## 运行时数据区
运行时数据区包含了：
### 程序计数器

可以看做是当前线程所执行的字节码的行号指示器。记录了一个java方法的虚拟机字节码指令的地址。

### java虚拟机栈

虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（stack frame）用于存储**局部变量表**、操作数栈、动态链接、方法出口等信息。

一般人所说的堆和栈，这里的栈就是指虚拟机栈，或者说虚拟机栈中的**局部变量表**

局部变量表存放了**编译器可知**的各种基本数据类型（boolean, byte, char, short, int,float, long, double），对象引用和returnAddress类型（指向了一条字节码指令的地址）

### 本地方法栈

虚拟机栈为执行`java`方法服务， 而本地方法栈为执行`Native`方法服务。

### java堆

存放对象实例，被所有线程共享的一块内存区域。

在分代收集算法中，还会细分成新生代和老年代，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

### 方法区

各个线程共享的内存区域，用于存储**已被虚拟机加载的类信息**、常量、静态变量、即时编译器编译后的代码等。很多人成为永久代（Permanent Generation）

除此以外，还需要了解**直接内存**，NIO就使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

优点是：避免在java堆和Native堆中来回复制数据



## HotSpot虚拟机

### 对象的创建

对象的创建时，分配内存的算法：

- 指针碰撞

java内存是规整的，指针的一边是用过的内存，一边是空闲的内存，把指针向空闲空间的那边挪动一段与对象大小相等的距离。

使用Serial，ParNew等带compact过程的收集器，通常使用指针碰撞。

- 空闲列表

维护一份列表，记录哪些内存是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

使用CMS这种基于Mark-Sweep算法的收集器，通常使用空闲列表。

### 对象的内存布局

